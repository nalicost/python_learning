# 前后端分离互通项目学习

## 定义

1. 前端：即客户端，负责渲染用户显示画面
2. 后端：即服务器，负责接收http请求处理数据

## 部分名词解析

1. API：Application Programming Interface，是一些预先定义的函数，或指软件系统不同组成部分衔接的约定

## 前后端分离，完整请求过程

### 文解

1. 前端通过http请求后端API
2. 后端以json形式返回前端数据
3. 前端生成用户显示界面

### 图解

![图片]()

## 是否判断标准（基于谁生成页面）

1. 后端生成，即前后端未分离
2. 前端生成，即前后端分离

## 优势

1. 各司其职
   1. 前端：视觉层面，兼容性，前端性能优化
   2. 后端：业务逻辑，并发（可承载的访问数），可用性（nginx的负载均衡），性能（综合）
2. 解耦，易扩展
3. 后端灵活搭配各类前端（iOS，Android，html，...）
4. 提高用户体验
5. 前后端可完全并行开发，加快开发效率

## 分离常见问题

1. 解决http无状态
   * 使用token
2. 前端使用js，解决跨域
   * 使用cors
3. 解决csrf问题
   * 采用token
4. Single Page Web Application对seo（Search Engine Optimization）效果的影响
   * 由于前后端分离后，页面不存在静态文字，会降低seo效率
5. 前后端数据校验
   * 前后端各做一遍，尤其是后端，必须做好数据库前的最后一道防线
6. 动静分离与前后端分离的区别
   * 动静分离：静态资源与服务器分开部署（典型方案，将静态资源交由CDN厂商处理）
   * 前后端分离：页面由前端生成

## token —— 令牌

### 前置知识

#### base64算法

##### 加密方法

1. 将字符串拆成每三个字符一组
2. 计算每一个字符对于的ascii码二进制
3. 将8位的二进制码，按照没6位重新分组，不足6位的在后面补0

##### python库方法（base64）

|方法|作用|参数|
|:----:|:----:|:----:|
|b64encode|将输入的参数转化为base64规则的串|预加密的明文，类型为bytes|
|b64decode|将base64串解密为明文|base64密文，类型为bytes|
|urlsafe_b64encode|作用同b64encode但是会将'+'替换成'-'，将'/'替换成'_'|同b64encode|
|urlsafe_b64decode|作用同b64decode，但只针对上一个方法的解密|同b64decode|

注：base64算法可逆，故可简单的被直接解析

#### 散列算法（hash）

##### 特点

1. 定长输出
2. 不可逆
3. 雪崩

##### 实例

1. SHA-256（安全散列算法的一种，基于hash）
   * 示例

     ```python

     import hashlib
     s = hashlib.sha256()
     s.update(b'xxx')
     s.digest()
     s.hexdigest()
     print(s)

     ```  

2. RSA256（一种非对称加密）
   1. 加密：公钥加密，私钥解密
   2. 签名：私钥签名，公钥验签  
3. python字典与set存储原理（老版本）
   1. 增加
      1. 对键做一次hash，经过一系列操作，得到对应的索引
      2. 当发生哈希碰撞时，会进行二次哈希，再经过一系列操作，得到对应的索引
   2. 删除
      1. 做一次哈希，如果key值相同，作伪删除
      2. 做一次哈希，发现key值不同，做二次哈希，直到键相同，作伪删除
   3. 扩容
      当空闲位置少于三分之一，扩容并重排位置（所以少用字典）

    注：故老版本字典与set都是无序的

4. python字典存储原理更新优化（新版本）
   1. 增加
      1. 对键做一次hash，经过一系列操作，得到对应的索引，此时在另一个辅助列表的对应ha的索引处按顺序存入在实际存储值的列表的索引
      2. 当发生哈希碰撞时，会进行二次哈希，再经过一系列操作，得到对应的索引，同上操作  

   注：故新版本python字典有序  

##### python库

1. hashlib（包含大量基于hash的算法加密库，使用如上示例所示）
2. hmac（包含大量基于hash的算法加密方法，并复合密钥作为盐进行加密的加密库）
   1. 使用示例

      ```python

      # 生成hmac对象
      # 第一个参数为加密的key串，即加盐的内容，bytes类型
      # 第二个参数为欲加密的串，bytes类型
      # 第三个参数为hmac的算法 

      h = hmac.new(key, b'XXX', digestmod='SHA256')
      h.digest()

      ```

##### CMD5

国内通过大量碰撞得到的一个密文反向解密，本质是一个密文与明文的一一映射表

### JWT - json-web-token

#### 组成

1. header
   * 格式：```{'alg': 'HS256', 'typ': 'JWT'}```
   * 参数：
     * 'alg'：即选择的加密算法
     * 'typ'：即使用JWT生成token
   * 注：一般可以省去头部，由于一般开发时会商定协议，同时其传输数据时占据带宽（如果想使用JWT的库的相关方法的话，则不能省去）
   * 呈现方式：先转成json串，再使用base64加密
2. payload
   * 格式：

    ```python

    payload = {
    # 内部提供的几个可选项，公有声明
    'exp': xxx, # 过期时间，为时间戳（expiration time）
    'iss': xxx, # token的签发者（issuer）
    'aud': xxx, # 指明此token签发面向群体(audience)
    'iat': xxx, # 指明此token的创建时间
    # 自己使用的相关内容，私有声明
    'param': xxx,
    ....,
    }
    ```

   * 注：公有声明中一般只使用第一个，即exp
   * 呈现方式：先转成json串，再使用base64加密

3. signature签名
   * 签名规则（以SHA256为例）
      * hmac.new(key, base64后的header + b'.' + base64后的payload， digestmod='SHA256')  
   * 呈现方式：直接使用base64加密

#### 结果格式

```header.payload.signature # 为bytes类型```
