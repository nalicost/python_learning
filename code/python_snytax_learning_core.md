# 正式的python核心的初步学习

## 模块

### 概念

包含一系列数据，函数，类的文件，通常以.py结尾（跨文件调用）

### 分类

* 内置模块（builtins）
* 标准库模块
* 第三方模块（自己安装）
* 用户自己编写的模块

### 导入语法

* ```import 文件名 as 别名```，通过变量名关联文件地址，调用模块内的成员要用文件名或别名来点出来
* ```from 文件名 import 模块内成员```，直接将模块内需要的内容导入作用域，可直接使用，但注意同名（其他模块和导入模块的文件中同名内容）冲突
* ```from 文件名 import *```，直接将模块内所有的内容导入作用域，可直接使用，但注意同名（其他模块和导入模块的文件同名内容）冲突

注：文件名前加上绝对路径可导入不同文件夹下的模块，但注意该文件的完整路径要包含该绝对路径，否则无法导入；文件的绝对路径间用```.```连接

### 模块变量（只有模块中有）

* ```__all__```，定义模块可导出成员，仅对```from 文件名 import *```生效
* ```__doc__```，导出文档字符串
* ```__file__```，模块对应的文件路径
* ```__name__```，非主模块时返回模块自身名字，是主模块时返回```__main__```
  * 其的一种运用：```if __name__ == '__main__'```
    * 在非主模块中，这句语句后面跟测试代码，使其不作为主模块运行时，代码不会执行，只有当其是主模块时才会运行
    * 在主模块中，这句语句跟程序入口，使程序只能从主入口运行。

### 内置模块time

* 获取时间戳：```time.time()```
* 时间戳-->时间元组：```tiem.localtime(时间戳)```，内容包含依次为年，月，日，时，分，秒，一周中的第几天，一年的第几天，夏令时
  注：一周中的第几天按中国换算要加一
* 时间元组-->时间戳：```time.mktime(时间元组)```
* 时间元组-->str：```time.strftime(格式, 时间元组)```，格式中%Y（完整年份），%y（年份后两位），%m（月份），%d（天），%H（时），&M（分），%S（秒）
* str-->时间元组：```time.strptime(str, 格式)```

## 包

### 概念

拥有__init__.py文件的文件夹

### python程序结构

1. 文件夹（项目根目录，即第一个运行文件所在位置）
2. 包
3. 模块
4. 类
5. 函数
6. 语句

### 导入

与导入模块一致，不多做赘述

注：pycharm中设置根目录时会自动将其路径加入该项目所有文件中，但在pycharm外运行会报错，可以通过```import sys```来使用```sys.path.append(路径)```来人工给文件加路径

### __init__.py作用

在__init__.py中使用```__all__```可以指定导包时能被导出的模块，仅对```from 包名.模块名 import *```生效

## 异常

### 定义

运行时检查到错误

### 现象

当异常发生时，程序不会再向下运行，而会返回调用者

### 类型（常用）

* 名称异常（NameError）：
* 类型异常（TypeError）
* 索引异常（IndexError）
* 属性异常（AttributeError）
* 键异常（KeyError）
* 未实现异常（NotImplementedError）
* 异常基类（Exception）

### 处理语句

* 作用：使程序不再报错，可以正常运行（即拦截异常的上翻，使程序强制向下执行）
* 语法如下：

    ```python
    try:
        可能异常语句
    except 异常1:
        处理语句1
    ...
    except: # 实际是except Exception
        不是以上的处理语句 
    else： # 有except才可有else
        未发生异常执行的语句
    finally： # 写finally时一般不写except，即不处理异常
        无论是否发生异常都会执行的语句
    ```

### raise语句

* 作用：抛出一个错误，使程序进入异常
* 目的：当调用层数较深时，快速返回表层，传递错误信息（raise无处理异常语句，就上翻而return需要一层层向外传递）
* 语法：```raise 异常类型```

### 自定义异常

* 作用：可以定义符合个性化条件的异常
* 语法

  ```python
  XXError(Exception):
    异常语句
  ```

  注：当在自定义异常写构造函数时，要先调用父类的，并将错误信息传入其中

## 迭代

### 定义

每一次对过程的重复称为一次迭代，而且每一次迭代的结果会成为下一次迭代的值（初始）

### 可迭代对象

* 定义: 具有__iter__方法（可以返回迭代器对象）的对象
* 语法:

    ```python
    class 类名:
        def __iter__(self):
            return 迭代器类名(self)
    ```

  注：迭代器对象需自己写

### 迭代器对象

* 定义：拥有```__next__()```方法（调用后可以依据算法返回下一个值的对象）的对象
* 语法

  ```python
  class 迭代器类名：
    def __init__(self, 聚合对象)：
        self.__聚合对象 = 聚合对象

    def __next__(self):
        if 没有元素：
            raise StopInteration
        return 聚合对象元素
  ```

### 迭代器框架

#### 使用

如下：

```python
class 类名:
    def __iter__(self):
        return 迭代器类名(self)


  class 迭代器类名：
    def __init__(self, 聚合对象)：
        self.__聚合对象 = 聚合对象

    def __next__(self):
        if 没有元素：
            raise StopInteration
        return 聚合对象元素

for item in 类名:
    print(item)
```

#### 内容

1. 抽象层（可迭代对象--父类）---> 实现层（自定义可迭代对象-->子类）
2. 抽象层（迭代器--父类） ---> 实现层（自定义迭代器-->子类）
3. 客户端代码（for协议） ---> 抽象层（依赖倒置）---> 具体迭代器与可迭代对象

#### for协议

##### 原理

一种协议，包含三个过程：

1. 获取迭代器
2. 调用迭代器的next，获取聚合对象的元素（循环）
3. 遇到异常，处理并完成迭代

##### 意义

通过可迭代对象与迭代器的继承与多态提供一种可以访问聚合类对象而不暴露其内部存储结构的方法

##### 实际语句

如下：

```python
iterator = 可迭代对象.__iter__()
while True:
    try:
        item = iterator.__next__()
        print(item)
    except StopInteration
        break
```

### 生成器

#### 定义

可迭代对象+迭代器

#### 作用

能够动态提供聚合类对象中聚合的元素（调用一次，计算一次，返回一次）

#### 特点

```__iter__()```方法返回的是其自身

#### 生成器的大致源码

如下：

```python
class MyGenerator:
        def __init__(self):
            pass

        def __iter__(self):
            return self

        def __next__(self):
            pass
```

#### 生成器的生成语法（生成器函数）

* 定义：包含yield的函数
* 原理：当函数中出现yield，调用时自动创建生成器类而不执行函数内所写的逻辑，其中将上一次循环yield以下，与本次循环yield以上代码放入```__next__()```方法中，并以本次循环yield后的内容作为返回值
* 作用：通过延迟操作（惰性操作），一个一个给出结果，减少内存压力
* 语法

    ```python
    def fun():
        方法体
        yield 返回值
        方法体
    ```

* 注意事项：由于生成器函数退出时会自动抛出StopInterationError异常，故当在生成器函数中写return不会返回return中的值，同时如果在其中再自己抛出StopInterationError异常，会导致重复抛出两个StopInterationError会致使程序抛出RunTimeError

#### 迭代器与生成器之间的关系

生成器主要就是迭代器，区别在于其还是可迭代对象，便于直接使用for来进行迭代

#### 生成器表达式

如下：
```(yield 返回值 for 循环语句 if 条件)```

注：只是一种简便写法，和写生成器函数本质没有区别

## 函数式编程

### 概念

以函数为单位进行开发

### 思想

与面向对象开发其实是一致的，除了不使用类，而是使用函数

### 高阶函数的运用

* 核心理念
  * 通过形参作为（父类），统一函数（子类）的概念   -->   继承
  * 高阶函数自身作为客户端代码，调用形参（父类）的逻辑（子类）   -->   多态
  * 来实现函数功能的普适性
* 实现做法
  1. 提取公共部分（成为高阶函数，即客户端代码）
  2. 封装变化部分（成为子类）---> 如果函数只有一个语句可以直接使用lambda函数
  3. 以变量作为参数传入公共部分 （参数即为父类，相当于组合复用）
* 建议：可以将相似公共部分都提取到一个模块中，方便以后调用

### 闭包

#### 基础概念

* 三要素
  * 必须有一个内嵌函数
  * 内嵌函数必须引用外部函数中变量
  * 外部函数返回值必须是内嵌函数
* 作用：使外部函数执行完不会立即释放栈帧，等待内嵌函数运行，使逻辑连续，执行完，不脱离当前逻辑
* 原理：由于返回内嵌函数，而内嵌函数使用外部函数变量，若外部栈帧销毁，内嵌函数无法执行保留，闭包将两个函数的执行环境整合
* 类比：类变量，类方法或实例变量，实例方法
* 语法

  ```python
  def fun01():
    变量 = None
    def fun02()
        nonlocal 变量
        变量 = 1
    
    return fun02
  ```

#### 运用（装饰器）

##### 作用

即在不更改原函数功能情况下为其添加新功能（开闭原则）

##### 原理

由于闭包可以返回方法体，同时可以捆绑内外函数的运行环境。故将旧函数方法体传入其中，将新旧函数的运行环境捆绑在一起，并通过闭包返回新方法体重写旧函数方法体，达成函数功能扩展的目标

##### 语法

* 初始语法如下：

    ```python
    def fun_new(fun_old):
        def wrapper(*args, **kwargs):
            # 保证参数不同的的旧函数也可传入
            新方法体
            fun_old(*args, **kwargs)
            # 拆解传入的元组和字典，化为位置与命名关键字形参

        return wrapper


    def fun_old(parameter, ......):
        旧方法体


    fun_old = fun_new(fun_old)
    ```

* 特点：在```fun_old = fun_new(fun_old)```语句前执行的内容依旧是原先的函数（未执行该语句，故旧函数还未重写）

---

* 简化语法如下：

    ```python
    def fun_new(fun_old):
        def wrapper(*args, **kwargs):
            # 保证参数不同的的旧函数也可传入
            新方法体
            fun_old(*args, **kwargs)
            # 拆解传入的元组和字典，化为位置与命名关键字形参

        return wrapper


    @fun_new
    def fun_old(parameter, ......):
        旧方法体
    ```

* 特点：装拆方便，只需更换或删除@的内容，即可完成取消或更换装饰器；其次只要是函数后的内容执行的语句都是重写之后的

# 结语

python核心的初步学习自此结束，剩余进阶内容见后续笔记，下一部分为python数据结构
